# Лабораторная работа 2
## Вариант: Medium

* **Цель:** Освоить работу с файловой системой средствами Python.
* **Библиотеки:** *os*, *pathlib*, *shutil*, *zipfile*, *tarfile*, *re*, *logging*
* **Допущения:**
  - При указании пути разделители '\\' и '/' равнозначны и могут использоваться одновременно
  - Имена файлов, содержащие пробелы, должны заключаться в *двойные* кавычки. Допускается заключать весь путь в двойные кавычки, но тогда имена файлов не должны быть в кавычках
  - Во избежание зацикливания процесса, запрещенно копировать директорию в её поддиректорию
  - При копировании и перемещении может происходить затирание, если в пути-назначении уже лежит файл с таким же названием
  - Перемещать текущую директорию запрещено
  - Перемещать директорию в её поддиректорию запрещено
  - При перемещении в несуществующую директорию, если её родительская директория так же не существует, то выдаётся ошибка. Иначе происходит перемещение с переименованием
  - При удалении каталога подтверждение запрашивается даже если этот каталог пустой
  - Удалять текущую, родительскую и корневую директории запрещено
  - Архив нельзя дполнить новыми файлами. Если в указанном архиве уже есть какие-то файлы, они удаляются и в архиве лежат только новые указанные файлы

* **Чему я научилась:**
    - Написание тестов с использованием Mock
    - Логирование команд и ошибок, в том числе логирование в разные файлы одновременно
    - Работа с файлами в Python

### Алгоритм решения
  1. Пользователь вводит запрос
  2. Введённый запрос логируется (файл *shell.log* и *.history*)
  3. Программа (функция **execute**) выделяет из этого запроса команду (первое слово), проверяет, существует ли такая команда, и отправляет оставшуюся часть запроса функции, исполняющей эту команду
  4. Из запроса выделяются опции и пути. Происходит валидация опций, проверяется возможность выполнения команды с указанным количеством путей
  5. Пути приводятся к нормализованному виду (функция **normalize_path**)
  6. Происходит валидация указанных путей и выполнение команды. О работе каждой из них в отдельности:
     - ```ls``` -  Отображение списка файлов и каталогов по указанному пути. С опцией ```-l``` помимо имён выводятся права доступа, размер файла и время послднего изменения. Если при вызове команды не указан путь, то берётся текущая директория. Проверяется, существует ли указанный путь. Затем собирается список файлов, лежащих в этом каталоге. Если путь ведёт к файлу, то в списке будет только сам файл. Если опция ```-l``` не указана, то этот список просто выводится с помощью print. Иначе в список также дополняется информацией о каждом файле (с помощью os.stat()) и уже после этого список выводится. Если доступа к какому-либо файлу нет, то на его месте будет строка с ошибкой, а все остальные файлы выведутся как обычно.
     - ```cd``` - Переход в указанный каталог. Если путь не указан, переход в домашнюю директорию. Проверяется, что указанный путь существует и является директорией, и происходит смена рабочей директории с помощью os.chdir(). Если нет доступа к каталогу, выводится ошибка.
     - ```cat``` - Вывод содержимого указанного файла в консоль. Указанный путь должен существовать, вести к файлу и быть доступным для чтения. Для получения содержимого файла используется метод .read(), а для вывода - print.
     - ```cp``` - Копирование файла из источника в назначение. С опцией ```-r``` возможно копирование каталогов вместе с их содержимым. Путь-источник должен существовать, путь-назначение может не существовать, но его родительская директория должна существовать. Назначение не может быть поддиректорией источника. Рассмотрим несколько случаев:
        - Если источник - файл, а назначение - существующая директория, то в этой директории появится копия файла
        - Источник - файл, назанчение - несуществующий путь: создание копии источника с именем как у назначения
        - Источник и назначение - файлы: замена файла-назначения на копию источника, но с именем как у назначения
        - Источник - директория, а назначение - существующая директория: *содержимое* источника скопируется в назаначение
        - Источник - директория, а назначение - несуществующий путь: создание копии источника с именем как у назначения
        - Источник - директория, а назначение - файл: ошибка
     Файлы копируются вместе с их содержимым. Для копирования директорий используется shutil.copytree(), а для файлов - shutil.copy2(). Если к одному из путей нет доступа, выводится ошибка.
     - ```mv``` - Перемещение или переименование файла/каталога. Путь-источник должен существовать, не может быть текущей директорией или её родительской директорией. Путь назначения должен существовать. Истоник и назначение не могут совпадать. Если источник - директория, то назначение не может быть файлом. Перемещение происходит с помощью shutil.move().
     - ```rm``` - Удаление указанного файла. С опцией ```-r``` рекурсивно удаляется каталог вместе со всем содержимым. Путь должен существовать, не может быть корневой, домашней, родительской или текущей директорией. При удалении каталога у пользователя просят подтверждение в формате [y/n]. Для удаления используется os.remove()
     - ```zip``` - Создание архива формата ZIP. Указывается файл или директория, которую необходимо архивировать, (источник) и сам архив. Источник должен уже существовать, а архив при необходимости будет создан. Есть в источнике есть пустые директории, они тоже добавляются в архив. Если в указанном архиве уже были какие-то файлы, они удаляются и в архив помещаются только новые указанные файлы.
     - ```unzip``` - Распаковка архива формата ZIP в текущую директорию.
     - ```tar``` - Создание архива формата TAR.GZ. Аналогична команде ```zip```.
     - ```untar``` - Распаковка архива формата TAR.GZ в текущую директорию.
     - ```grep``` - Поиск строк, соответствующих шаблону, в указанных файлах. С опцией ```-r``` возможен рекурсивный посик в каталогах, а с ```-i``` происходит поиск без учёта регистра. Перед выполнением проверяется валидность паттерна, существование файла, доступ к нему. Указанный паттерн должен быть составлен по формату, принятому в Python. Если указанный путь - файл, просто осуществляется поиск по нему. Если несколько файлов или каталог, то тем же образом проходимся по каждому файлу. Формат вывода: имя файла, номер строки и найденный фрагмент.
     - ```history``` - Вывод истории введённых пользоватлем команд. По умолчанию выводятся последние 10 операций, но можно указать своё количество. Информация берётся из файла *.history*, куда в процессе работы логируются команды. Содержимое этого файла сохраняется между запусками программы. Для демонстрации в репозитории уже лежит вайл .history с некоторой историей команд.
     - ```undo``` - Отмена последней операции типа ```cp```, ```mv``` или ```rm```. Необхоимая для отмены информация записывается в файл *.trash* в процессе выполнения команд копирования, перемещения и удаления. При отмене операции ```rm``` восстанавливается и структура каталогов, и содержимое файлов. После отмены лог об операции удаляется из файла *.trash*. Если на момент вызова команды файл пуст, выдаётся ошибка.
     - ```help``` - Вывод сообщения с информацией о доступных командах.
  8. Сообщение с ошибкой или сообщение об успешном выполнении логируется (файл *shell.log*) 
  9. Возврат к шагу 1

## Интересные тест-кейсы
В целом было написано 72 теста для проверки возможных ошибок и успешных кейсов каждой команды. Все их можно посмотреть в папке tests. А вот некоторые тест-кейсы, которые мне было интересно посмотреть:
 - Относительные пути без ./
 - ls с указанием пути к пустой директории
 - ls с апострофом (') в названии файла
 - Переименование с недопустимым названием (В программе не предусмотрено специальной ошибки в целях кроссплатформенности, но выдастся OSError)
 - cat файлов с расширением .docx
 - cat файла src/cat.py :)
 - Архивирование пустой директории

## Инструкция к использованию

### Установить репозиторий
```pip install -e git+https://github.com/miniMlena/lab2_python.git#egg=lab2-python``` \
```cd src```

### Запустить
Сама программа:
```python -m src.main```
Тесты:
```pytest```

### Синтаксис
* В качестве разделителей используются '\\' и '/'
* Обозначение команд и опций аналогично командам в Linux
* Опции можно перечислять как по отдельности, так и слитно после общего '-'
* В команде grep используются регулярные выражения, принятые в Python, и их не нужно заключать в кавычки
