# Лабораторная работа 2
## Вариант: Easy

* **Цель:** Освоить работу с файловой системой средствами Python.
* **Библиотеки:** *os*, *pathlib*, *shutil*, *re*, *logging*
* **Допущения:**
  - При указании пути разделители '\' и '/' равнозначны и могут использоваться одновременно
  - Имена файлов, содержащие пробелы, должны заключаться в *двойные* кавычки. Допускается заключать весь путь в двойные кавычки, но тогда имена файлов не должны быть в кавычках
  - Во избежание зацикливания процесса, запрещенно копировать директорию в её поддиректорию
  - При копировании и перемещении может происходить затирание, если в пути-назначении уже лежал файл с таким же названием
  - Перемещать текущую директорию запрещено
  - Перемещать директорию в её поддиректорию запрещено
  - При перемещении в несуществующую директорию, если её родительская директория так же не существует, то выдаётся ошибка. Иначе происходит перемещение с переименованием
  - При удалении каталога подтверждение запрашивается даже если этот каталог пустой
  - Удалять текущую, родительскую и корневую директории запрещено

* **Чему я научилась:**
    - Написание тестов с использованием Mock
    - Логирование команд и ошибок
    - Работа с файлами в Python

### Алгоритм решения
  1. Пользователь вводит запрос
  2. Программа (функция **execute**) выделяет из этого запроса команду (первое слово), проверяет, существует ли такая команда, и отправляет оставшуюся часть запроса функции, исполняющей эту команду
  3. Из запроса выделяются опции и пути. Происходит валидация опций, проверяется возможность выполнения команды с указанным количеством путей
  4. Пути приводятся к нормализованному виду (функция **normalize_path**)
  5. Происходит валидация указанных путей и выполнение команды. О работе каждой из них в отдельности:
     - ```ls``` -  Отображение списка файлов и каталогов по указанному пути. С опцией ```-l``` помимо имён выводятся права доступа, размер файла и время послднего изменения. Если при вызове команды не указан путь, то берётся текущая директория. Проверяется, существует ли указанный путь. Затем собирается список файлов, лежащих в этом каталоге. Если путь ведёт к файлу, то в списке будет только сам файл. Если опция ```-l``` не указана, то этот список просто выводится с помощью print. Иначе в список также дополняется информацией о каждом файле (с помощью os.stat()) и уже после этого список выводится. Если доступа к какому-либо файлу нет, то на его месте будет строка с ошибкой, а все остальные файлы выведутся как обычно.
     - ```cd``` - Переход в указанный каталог. Если путь не указан, переход в домашнюю директорию. Проверяется, что указанный путь существует и является директорией, и происходит смена рабочей директории с помощью os.chdir(). Если нет доступа к каталогу, выводится ошибка.
     - ```cat``` - Вывод содержимого указанного файла в консоль. Указанный путь должен существовать, вести к файлу и быть доступным для чтения. Для получения содержимого файла используется метод .read(), а для вывода - print.
     - ```cp``` - Копирование файла из источника в назначение. С опцией ```-r``` возможно копирование каталогов вместе с их содержимым. Путь-источник должен существовать, путь-назначение может не существовать, но его родительская директория должна существовать. Назначение не может быть поддиректорией источника. Рассмотрим несколько случаев:
        - Если источник - файл, а назначение - существующая директория, то в этой директории появится копия файла
        - Источник - файл, назанчение - несуществующий путь: создание копии источника с именем как у назначения
        - Источник и назначение - файлы: замена файла-назначения на копию источника, но с именем как у назначения
        - Источник - директория, а назначение - существующая директория: *содержимое* источника скопируется в назаначение
        - Источник - директория, а назначение - несуществующий путь: создание копии источника с именем как у назначения
        - Источник - директория, а назначение - файл: ошибка
     Файлы копируются вместе с их содержимым. Для копирования директорий используется shutil.copytree(), а для файлов - shutil.copy2(). Если к одному из путей нет доступа, выводится ошибка.
     - ```mv``` - Перемещение или переименование файла/каталога. Путь-источник должен существовать, не может быть текущей директорией или её родительской директорией. Истоник и назначение не могут совпадать.
     - ```rm``` - Удаление указанного файла. С опцией ```-r``` рекурсивно удаляется каталог вместе со всем содержимым. Путь должен существовать, не может быть корневой, домашней, родительской или текущей директорией. При удалении каталога у пользователя просят подтверждение в формате [y/n]. Для удаления используется os.remove()
  6. Все заданные имена попадают в глобальный scope имен(extra.types.Context), в котором содержатся заданные свойства и выражение, тождественное заданному имени
  7. Скомпилированное выражение попадает в токенизатор, который итерируется по выражению работает по следующим правилам:
        - Если это + или -, вводится доп. флаг(по умолчанию True): если след. символ можно представить в виде числа(например, это функция, переменная или просто число), флаг становится False
        - Для текущего символа находятся все имена, которые начинаются с последнего добавленного токена + текущего символа. Если такие имена существуют(+доп флаг), к последнему токену приписывается текущий символ, переход к след символу
        - Если есть имена, начинающиеся с текущего символа(+доп флаг), он добавляется к списку токенов, переход к след символу
        - Если символ - пробел, предыдущий токен пробелом не является, он добавляется к списку токенов
        - Если символ - число(+ '.' и 'е') и предыдущий токен тоже число, символ добавляется к предыдущему токену; если предыдущий токен числом не является, текущий токен добавляется к новому
        - Если предыдущий токен - функция, текущий символ - не '(', поднимается ошибка
        - Если предыдущий токен - функция, текущий символ - '(', к токенам добавляется '[', функция записывается в **стэк функций**, содержащий в себе имя функции, кол-во аргументов, баланс скобок
        - Если текущий символ - скобка она добавляется к токенам
        - Если текущий символ - '(', **стэк функций** не пуст, к балансу скобок добавляется 1
        - Если текущий символ - ')', **стэк функций** не пуст, из баланса скобок вычитается 1. Если баланс скобок стал отрицательным, заменяется добавленную ')' на ']'. Если кол-во аргументов меньше минимального, поднимается ошибка
        - Если текущий символ - ',', добавляем к количеству аргументов последней функции добавляется 1. Если аргументов больше максимального количества, вызывается ошибка
        - Если кол-во токенов не менее 2, проверяется, не попадает ли второй с конца токен в **буфер внешних имен** (см. ниже)
        - Если кол-во токенов не менее 3, 2 с конца токен - пробел, 3 и 1 с конца токены могут быть представлены числами, вызывается ошибка
        - В конце проверяется, не начинается ли список токенов с операций, не попадает ли последний токен в **буфер внешних имен**
  8. 
  9. Результат возвращается и выводится пользователю
  10. Возврат к шагу 1

## Интересные тест-кейсы
 - Скобки сбалансированы по количеству, но введены как )(
 - Функции, операторы, переменные, перезаписывают системные имена и функции по умолчанию(н., ```def max(): return 1; let return = 3; operator 'operator': ...```)
 - Рекурсивно-заданные имена(```def f(x): return f(x); let x = x+5; operator '->': 2, l->r, false;...```)
 - Пустые скобки(не у функции)
 - Пустые скобки(фукнция без аргументов)
 - Аргумент без значения по умолчанию после аргумента со значением по умолчанию

## Инструкция к использованию

### Установить репозиторий
```pip install -e git+https://github.com/miniMlena/lab2_python.git#egg=minishell``` \
```cd src/lab2_python```

### Запустить
Сама программа:
```python -m src.main```
Тесты:
```pytest```

### Синтаксис
* В качестве разделителей используются '\' и '/'
